{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"C:\\Users\\N_Has\\Desktop\\FIT3170\\2025W1-All-In-One\\Application\\all-in-one\\packages\\mongo\\collection\\methods_replication.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","topLevelAwait","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"packages/mongo/collection/methods_replication.js","filename":"C:\\Users\\N_Has\\Desktop\\FIT3170\\2025W1-All-In-One\\Application\\all-in-one\\packages\\mongo\\collection\\methods_replication.js","targets":{},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"C:\\Users\\N_Has\\Desktop\\FIT3170\\2025W1-All-In-One\\Application\\all-in-one","root":"C:\\Users\\N_Has\\Desktop\\FIT3170\\2025W1-All-In-One\\Application\\all-in-one","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":true,"enforceStrictMode":false,"dynamicImport":true},"externalDependencies":[]},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.17.2","helpers":true,"useESModules":false,"corejs":false},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true},"externalDependencies":[]},{"key":"base$0$3","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"base$0$4","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-jsx","visitor":{"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXFragment":{"exit":[null]},"JSXElement":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false},"externalDependencies":[]},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-nullish-coalescing-operator","visitor":{"LogicalExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-chaining","visitor":{"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-optional-catch-binding","visitor":{"CatchClause":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-class-properties","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-async-generator-functions","visitor":{"Program":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"proposal-logical-assignment-operators","visitor":{"AssignmentExpression":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null,null]},"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"DoWhileStatement":{"exit":[null]},"ForInStatement":{"exit":[null]},"ForStatement":{"exit":[null]},"WhileStatement":{"exit":[null]},"ForOfStatement":{"exit":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true},"externalDependencies":[]},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"StaticBlock":{"enter":[null]},"TSModuleBlock":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectPattern":{"enter":[null]}},"options":{},"externalDependencies":[]},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{},"externalDependencies":[]},{"key":"transform-regenerator","visitor":{"ObjectMethod":{"enter":[null],"exit":[null]},"ClassMethod":{"enter":[null],"exit":[null]},"ClassPrivateMethod":{"enter":[null],"exit":[null]},"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"CallExpression":{"enter":[null]}},"options":{},"externalDependencies":[]}],"presets":[],"generatorOpts":{"filename":"C:\\Users\\N_Has\\Desktop\\FIT3170\\2025W1-All-In-One\\Application\\all-in-one\\packages\\mongo\\collection\\methods_replication.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/mongo/collection/methods_replication.js"}},"code":"var _regeneratorRuntime;\nmodule.link(\"@babel/runtime/regenerator\", {\n  default: function (v) {\n    _regeneratorRuntime = v;\n  }\n}, 0);\nvar _objectSpread;\nmodule.link(\"@babel/runtime/helpers/objectSpread2\", {\n  default: function (v) {\n    _objectSpread = v;\n  }\n}, 1);\nmodule.export({\n  ReplicationMethods: function () {\n    return ReplicationMethods;\n  }\n});\nvar ReplicationMethods = {\n  _maybeSetUpReplication: function () {\n    function _callee6(name) {\n      var _registerStoreResult, _registerStoreResult$;\n      var self, wrappedStoreCommon, wrappedStoreClient, wrappedStoreServer, registerStoreResult, message, logWarn;\n      return _regeneratorRuntime.async(function () {\n        function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              self = this;\n              if (self._connection && self._connection.registerStoreClient && self._connection.registerStoreServer) {\n                _context6.next = 3;\n                break;\n              }\n              return _context6.abrupt(\"return\");\n            case 3:\n              wrappedStoreCommon = {\n                // Called around method stub invocations to capture the original versions\n                // of modified documents.\n                saveOriginals: function () {\n                  self._collection.saveOriginals();\n                },\n                retrieveOriginals: function () {\n                  return self._collection.retrieveOriginals();\n                },\n                // To be able to get back to the collection from the store.\n                _getCollection: function () {\n                  return self;\n                }\n              };\n              wrappedStoreClient = _objectSpread({\n                // Called at the beginning of a batch of updates. batchSize is the number\n                // of update calls to expect.\n                //\n                // XXX This interface is pretty janky. reset probably ought to go back to\n                // being its own function, and callers shouldn't have to calculate\n                // batchSize. The optimization of not calling pause/remove should be\n                // delayed until later: the first call to update() should buffer its\n                // message, and then we can either directly apply it at endUpdate time if\n                // it was the only update, or do pauseObservers/apply/apply at the next\n                // update() if there's another one.\n                beginUpdate: function () {\n                  function _callee(batchSize, reset) {\n                    return _regeneratorRuntime.async(function () {\n                      function _callee$(_context) {\n                        while (1) switch (_context.prev = _context.next) {\n                          case 0:\n                            // pause observers so users don't see flicker when updating several\n                            // objects at once (including the post-reconnect reset-and-reapply\n                            // stage), and so that a re-sorting of a query can take advantage of the\n                            // full _diffQuery moved calculation instead of applying change one at a\n                            // time.\n                            if (batchSize > 1 || reset) self._collection.pauseObservers();\n                            if (!reset) {\n                              _context.next = 4;\n                              break;\n                            }\n                            _context.next = 4;\n                            return _regeneratorRuntime.awrap(self._collection.remove({}));\n                          case 4:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                      return _callee$;\n                    }(), null, null, null, Promise);\n                  }\n                  return _callee;\n                }(),\n                // Apply an update.\n                // XXX better specify this interface (not in terms of a wire message)?\n                update: function (msg) {\n                  var mongoId = MongoID.idParse(msg.id);\n                  var doc = self._collection._docs.get(mongoId);\n\n                  //When the server's mergebox is disabled for a collection, the client must gracefully handle it when:\n                  // *We receive an added message for a document that is already there. Instead, it will be changed\n                  // *We reeive a change message for a document that is not there. Instead, it will be added\n                  // *We receive a removed messsage for a document that is not there. Instead, noting wil happen.\n\n                  //Code is derived from client-side code originally in peerlibrary:control-mergebox\n                  //https://github.com/peerlibrary/meteor-control-mergebox/blob/master/client.coffee\n\n                  //For more information, refer to discussion \"Initial support for publication strategies in livedata server\":\n                  //https://github.com/meteor/meteor/pull/11151\n                  if (Meteor.isClient) {\n                    if (msg.msg === 'added' && doc) {\n                      msg.msg = 'changed';\n                    } else if (msg.msg === 'removed' && !doc) {\n                      return;\n                    } else if (msg.msg === 'changed' && !doc) {\n                      msg.msg = 'added';\n                      var _ref = msg.fields;\n                      for (var field in meteorBabelHelpers.sanitizeForInObject(_ref)) {\n                        var value = _ref[field];\n                        if (value === void 0) {\n                          delete msg.fields[field];\n                        }\n                      }\n                    }\n                  }\n                  // Is this a \"replace the whole doc\" message coming from the quiescence\n                  // of method writes to an object? (Note that 'undefined' is a valid\n                  // value meaning \"remove it\".)\n                  if (msg.msg === 'replace') {\n                    var replace = msg.replace;\n                    if (!replace) {\n                      if (doc) self._collection.remove(mongoId);\n                    } else if (!doc) {\n                      self._collection.insert(replace);\n                    } else {\n                      // XXX check that replace has no $ ops\n                      self._collection.update(mongoId, replace);\n                    }\n                    return;\n                  } else if (msg.msg === 'added') {\n                    if (doc) {\n                      throw new Error('Expected not to find a document already present for an add');\n                    }\n                    self._collection.insert(_objectSpread({\n                      _id: mongoId\n                    }, msg.fields));\n                  } else if (msg.msg === 'removed') {\n                    if (!doc) throw new Error('Expected to find a document already present for removed');\n                    self._collection.remove(mongoId);\n                  } else if (msg.msg === 'changed') {\n                    if (!doc) throw new Error('Expected to find a document to change');\n                    var keys = Object.keys(msg.fields);\n                    if (keys.length > 0) {\n                      var modifier = {};\n                      keys.forEach(function (key) {\n                        var value = msg.fields[key];\n                        if (EJSON.equals(doc[key], value)) {\n                          return;\n                        }\n                        if (typeof value === 'undefined') {\n                          if (!modifier.$unset) {\n                            modifier.$unset = {};\n                          }\n                          modifier.$unset[key] = 1;\n                        } else {\n                          if (!modifier.$set) {\n                            modifier.$set = {};\n                          }\n                          modifier.$set[key] = value;\n                        }\n                      });\n                      if (Object.keys(modifier).length > 0) {\n                        self._collection.update(mongoId, modifier);\n                      }\n                    }\n                  } else {\n                    throw new Error(\"I don't know how to deal with this message\");\n                  }\n                },\n                // Called at the end of a batch of updates.livedata_connection.js:1287\n                endUpdate: function () {\n                  self._collection.resumeObserversClient();\n                },\n                // Used to preserve current versions of documents across a store reset.\n                getDoc: function (id) {\n                  return self.findOne(id);\n                }\n              }, wrappedStoreCommon);\n              wrappedStoreServer = _objectSpread({\n                beginUpdate: function () {\n                  function _callee2(batchSize, reset) {\n                    return _regeneratorRuntime.async(function () {\n                      function _callee2$(_context2) {\n                        while (1) switch (_context2.prev = _context2.next) {\n                          case 0:\n                            if (batchSize > 1 || reset) self._collection.pauseObservers();\n                            if (!reset) {\n                              _context2.next = 4;\n                              break;\n                            }\n                            _context2.next = 4;\n                            return _regeneratorRuntime.awrap(self._collection.removeAsync({}));\n                          case 4:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                      return _callee2$;\n                    }(), null, null, null, Promise);\n                  }\n                  return _callee2;\n                }(),\n                update: function () {\n                  function _callee3(msg) {\n                    var mongoId, doc, replace, keys, modifier;\n                    return _regeneratorRuntime.async(function () {\n                      function _callee3$(_context3) {\n                        while (1) switch (_context3.prev = _context3.next) {\n                          case 0:\n                            mongoId = MongoID.idParse(msg.id);\n                            doc = self._collection._docs.get(mongoId); // Is this a \"replace the whole doc\" message coming from the quiescence\n                            // of method writes to an object? (Note that 'undefined' is a valid\n                            // value meaning \"remove it\".)\n                            if (!(msg.msg === 'replace')) {\n                              _context3.next = 20;\n                              break;\n                            }\n                            replace = msg.replace;\n                            if (replace) {\n                              _context3.next = 10;\n                              break;\n                            }\n                            if (!doc) {\n                              _context3.next = 8;\n                              break;\n                            }\n                            _context3.next = 8;\n                            return _regeneratorRuntime.awrap(self._collection.removeAsync(mongoId));\n                          case 8:\n                            _context3.next = 17;\n                            break;\n                          case 10:\n                            if (doc) {\n                              _context3.next = 15;\n                              break;\n                            }\n                            _context3.next = 13;\n                            return _regeneratorRuntime.awrap(self._collection.insertAsync(replace));\n                          case 13:\n                            _context3.next = 17;\n                            break;\n                          case 15:\n                            _context3.next = 17;\n                            return _regeneratorRuntime.awrap(self._collection.updateAsync(mongoId, replace));\n                          case 17:\n                            return _context3.abrupt(\"return\");\n                          case 20:\n                            if (!(msg.msg === 'added')) {\n                              _context3.next = 27;\n                              break;\n                            }\n                            if (!doc) {\n                              _context3.next = 23;\n                              break;\n                            }\n                            throw new Error('Expected not to find a document already present for an add');\n                          case 23:\n                            _context3.next = 25;\n                            return _regeneratorRuntime.awrap(self._collection.insertAsync(_objectSpread({\n                              _id: mongoId\n                            }, msg.fields)));\n                          case 25:\n                            _context3.next = 47;\n                            break;\n                          case 27:\n                            if (!(msg.msg === 'removed')) {\n                              _context3.next = 34;\n                              break;\n                            }\n                            if (doc) {\n                              _context3.next = 30;\n                              break;\n                            }\n                            throw new Error('Expected to find a document already present for removed');\n                          case 30:\n                            _context3.next = 32;\n                            return _regeneratorRuntime.awrap(self._collection.removeAsync(mongoId));\n                          case 32:\n                            _context3.next = 47;\n                            break;\n                          case 34:\n                            if (!(msg.msg === 'changed')) {\n                              _context3.next = 46;\n                              break;\n                            }\n                            if (doc) {\n                              _context3.next = 37;\n                              break;\n                            }\n                            throw new Error('Expected to find a document to change');\n                          case 37:\n                            keys = Object.keys(msg.fields);\n                            if (!(keys.length > 0)) {\n                              _context3.next = 44;\n                              break;\n                            }\n                            modifier = {};\n                            keys.forEach(function (key) {\n                              var value = msg.fields[key];\n                              if (EJSON.equals(doc[key], value)) {\n                                return;\n                              }\n                              if (typeof value === 'undefined') {\n                                if (!modifier.$unset) {\n                                  modifier.$unset = {};\n                                }\n                                modifier.$unset[key] = 1;\n                              } else {\n                                if (!modifier.$set) {\n                                  modifier.$set = {};\n                                }\n                                modifier.$set[key] = value;\n                              }\n                            });\n                            if (!(Object.keys(modifier).length > 0)) {\n                              _context3.next = 44;\n                              break;\n                            }\n                            _context3.next = 44;\n                            return _regeneratorRuntime.awrap(self._collection.updateAsync(mongoId, modifier));\n                          case 44:\n                            _context3.next = 47;\n                            break;\n                          case 46:\n                            throw new Error(\"I don't know how to deal with this message\");\n                          case 47:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }\n                      return _callee3$;\n                    }(), null, null, null, Promise);\n                  }\n                  return _callee3;\n                }(),\n                // Called at the end of a batch of updates.\n                endUpdate: function () {\n                  function _callee4() {\n                    return _regeneratorRuntime.async(function () {\n                      function _callee4$(_context4) {\n                        while (1) switch (_context4.prev = _context4.next) {\n                          case 0:\n                            _context4.next = 2;\n                            return _regeneratorRuntime.awrap(self._collection.resumeObserversServer());\n                          case 2:\n                          case \"end\":\n                            return _context4.stop();\n                        }\n                      }\n                      return _callee4$;\n                    }(), null, null, null, Promise);\n                  }\n                  return _callee4;\n                }(),\n                // Used to preserve current versions of documents across a store reset.\n                getDoc: function () {\n                  function _callee5(id) {\n                    return _regeneratorRuntime.async(function () {\n                      function _callee5$(_context5) {\n                        while (1) switch (_context5.prev = _context5.next) {\n                          case 0:\n                            return _context5.abrupt(\"return\", self.findOneAsync(id));\n                          case 1:\n                          case \"end\":\n                            return _context5.stop();\n                        }\n                      }\n                      return _callee5$;\n                    }(), null, null, null, Promise);\n                  }\n                  return _callee5;\n                }()\n              }, wrappedStoreCommon); // OK, we're going to be a slave, replicating some remote\n              // database, except possibly with some temporary divergence while\n              // we have unacknowledged RPC's.\n              if (Meteor.isClient) {\n                registerStoreResult = self._connection.registerStoreClient(name, wrappedStoreClient);\n              } else {\n                registerStoreResult = self._connection.registerStoreServer(name, wrappedStoreServer);\n              }\n              message = \"There is already a collection named \\\"\" + name + \"\\\"\";\n              logWarn = function () {\n                console.warn ? console.warn(message) : console.log(message);\n              };\n              if (registerStoreResult) {\n                _context6.next = 11;\n                break;\n              }\n              return _context6.abrupt(\"return\", logWarn());\n            case 11:\n              return _context6.abrupt(\"return\", (_registerStoreResult = registerStoreResult) === null || _registerStoreResult === void 0 ? void 0 : (_registerStoreResult$ = _registerStoreResult.then) === null || _registerStoreResult$ === void 0 ? void 0 : _registerStoreResult$.call(_registerStoreResult, function (ok) {\n                if (!ok) {\n                  logWarn();\n                }\n              }));\n            case 12:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n        return _callee6$;\n      }(), null, this, null, Promise);\n    }\n    return _callee6;\n  }()\n};","map":{"version":3,"names":["_regeneratorRuntime","module","link","default","v","_objectSpread","export","ReplicationMethods","_maybeSetUpReplication","_callee6","name","_registerStoreResult","_registerStoreResult$","self","wrappedStoreCommon","wrappedStoreClient","wrappedStoreServer","registerStoreResult","message","logWarn","async","_callee6$","_context6","prev","next","_connection","registerStoreClient","registerStoreServer","abrupt","saveOriginals","_collection","retrieveOriginals","_getCollection","beginUpdate","_callee","batchSize","reset","_callee$","_context","pauseObservers","awrap","remove","stop","Promise","update","msg","mongoId","MongoID","idParse","id","doc","_docs","get","Meteor","isClient","_ref","fields","field","meteorBabelHelpers","sanitizeForInObject","value","replace","insert","Error","_id","keys","Object","length","modifier","forEach","key","EJSON","equals","$unset","$set","endUpdate","resumeObserversClient","getDoc","findOne","_callee2","_callee2$","_context2","removeAsync","_callee3","_callee3$","_context3","insertAsync","updateAsync","_callee4","_callee4$","_context4","resumeObserversServer","_callee5","_callee5$","_context5","findOneAsync","console","warn","log","then","call","ok"],"sources":["packages/mongo/collection/methods_replication.js"],"sourcesContent":["export const ReplicationMethods = {\n  async _maybeSetUpReplication(name) {\n    const self = this;\n    if (\n      !(\n        self._connection &&\n        self._connection.registerStoreClient &&\n        self._connection.registerStoreServer\n      )\n    ) {\n      return;\n    }\n\n\n    const wrappedStoreCommon = {\n      // Called around method stub invocations to capture the original versions\n      // of modified documents.\n      saveOriginals() {\n        self._collection.saveOriginals();\n      },\n      retrieveOriginals() {\n        return self._collection.retrieveOriginals();\n      },\n      // To be able to get back to the collection from the store.\n      _getCollection() {\n        return self;\n      },\n    };\n    const wrappedStoreClient = {\n      // Called at the beginning of a batch of updates. batchSize is the number\n      // of update calls to expect.\n      //\n      // XXX This interface is pretty janky. reset probably ought to go back to\n      // being its own function, and callers shouldn't have to calculate\n      // batchSize. The optimization of not calling pause/remove should be\n      // delayed until later: the first call to update() should buffer its\n      // message, and then we can either directly apply it at endUpdate time if\n      // it was the only update, or do pauseObservers/apply/apply at the next\n      // update() if there's another one.\n      async beginUpdate(batchSize, reset) {\n        // pause observers so users don't see flicker when updating several\n        // objects at once (including the post-reconnect reset-and-reapply\n        // stage), and so that a re-sorting of a query can take advantage of the\n        // full _diffQuery moved calculation instead of applying change one at a\n        // time.\n        if (batchSize > 1 || reset) self._collection.pauseObservers();\n\n        if (reset) await self._collection.remove({});\n      },\n\n      // Apply an update.\n      // XXX better specify this interface (not in terms of a wire message)?\n      update(msg) {\n        var mongoId = MongoID.idParse(msg.id);\n        var doc = self._collection._docs.get(mongoId);\n\n        //When the server's mergebox is disabled for a collection, the client must gracefully handle it when:\n        // *We receive an added message for a document that is already there. Instead, it will be changed\n        // *We reeive a change message for a document that is not there. Instead, it will be added\n        // *We receive a removed messsage for a document that is not there. Instead, noting wil happen.\n\n        //Code is derived from client-side code originally in peerlibrary:control-mergebox\n        //https://github.com/peerlibrary/meteor-control-mergebox/blob/master/client.coffee\n\n        //For more information, refer to discussion \"Initial support for publication strategies in livedata server\":\n        //https://github.com/meteor/meteor/pull/11151\n        if (Meteor.isClient) {\n          if (msg.msg === 'added' && doc) {\n            msg.msg = 'changed';\n          } else if (msg.msg === 'removed' && !doc) {\n            return;\n          } else if (msg.msg === 'changed' && !doc) {\n            msg.msg = 'added';\n            const _ref = msg.fields;\n            for (let field in _ref) {\n              const value = _ref[field];\n              if (value === void 0) {\n                delete msg.fields[field];\n              }\n            }\n          }\n        }\n        // Is this a \"replace the whole doc\" message coming from the quiescence\n        // of method writes to an object? (Note that 'undefined' is a valid\n        // value meaning \"remove it\".)\n        if (msg.msg === 'replace') {\n          var replace = msg.replace;\n          if (!replace) {\n            if (doc) self._collection.remove(mongoId);\n          } else if (!doc) {\n            self._collection.insert(replace);\n          } else {\n            // XXX check that replace has no $ ops\n            self._collection.update(mongoId, replace);\n          }\n          return;\n        } else if (msg.msg === 'added') {\n          if (doc) {\n            throw new Error(\n              'Expected not to find a document already present for an add'\n            );\n          }\n          self._collection.insert({ _id: mongoId, ...msg.fields });\n        } else if (msg.msg === 'removed') {\n          if (!doc)\n            throw new Error(\n              'Expected to find a document already present for removed'\n            );\n          self._collection.remove(mongoId);\n        } else if (msg.msg === 'changed') {\n          if (!doc) throw new Error('Expected to find a document to change');\n          const keys = Object.keys(msg.fields);\n          if (keys.length > 0) {\n            var modifier = {};\n            keys.forEach(key => {\n              const value = msg.fields[key];\n              if (EJSON.equals(doc[key], value)) {\n                return;\n              }\n              if (typeof value === 'undefined') {\n                if (!modifier.$unset) {\n                  modifier.$unset = {};\n                }\n                modifier.$unset[key] = 1;\n              } else {\n                if (!modifier.$set) {\n                  modifier.$set = {};\n                }\n                modifier.$set[key] = value;\n              }\n            });\n            if (Object.keys(modifier).length > 0) {\n              self._collection.update(mongoId, modifier);\n            }\n          }\n        } else {\n          throw new Error(\"I don't know how to deal with this message\");\n        }\n      },\n\n      // Called at the end of a batch of updates.livedata_connection.js:1287\n      endUpdate() {\n        self._collection.resumeObserversClient();\n      },\n\n      // Used to preserve current versions of documents across a store reset.\n      getDoc(id) {\n        return self.findOne(id);\n      },\n\n      ...wrappedStoreCommon,\n    };\n    const wrappedStoreServer = {\n      async beginUpdate(batchSize, reset) {\n        if (batchSize > 1 || reset) self._collection.pauseObservers();\n\n        if (reset) await self._collection.removeAsync({});\n      },\n\n      async update(msg) {\n        var mongoId = MongoID.idParse(msg.id);\n        var doc = self._collection._docs.get(mongoId);\n\n        // Is this a \"replace the whole doc\" message coming from the quiescence\n        // of method writes to an object? (Note that 'undefined' is a valid\n        // value meaning \"remove it\".)\n        if (msg.msg === 'replace') {\n          var replace = msg.replace;\n          if (!replace) {\n            if (doc) await self._collection.removeAsync(mongoId);\n          } else if (!doc) {\n            await self._collection.insertAsync(replace);\n          } else {\n            // XXX check that replace has no $ ops\n            await self._collection.updateAsync(mongoId, replace);\n          }\n          return;\n        } else if (msg.msg === 'added') {\n          if (doc) {\n            throw new Error(\n              'Expected not to find a document already present for an add'\n            );\n          }\n          await self._collection.insertAsync({ _id: mongoId, ...msg.fields });\n        } else if (msg.msg === 'removed') {\n          if (!doc)\n            throw new Error(\n              'Expected to find a document already present for removed'\n            );\n          await self._collection.removeAsync(mongoId);\n        } else if (msg.msg === 'changed') {\n          if (!doc) throw new Error('Expected to find a document to change');\n          const keys = Object.keys(msg.fields);\n          if (keys.length > 0) {\n            var modifier = {};\n            keys.forEach(key => {\n              const value = msg.fields[key];\n              if (EJSON.equals(doc[key], value)) {\n                return;\n              }\n              if (typeof value === 'undefined') {\n                if (!modifier.$unset) {\n                  modifier.$unset = {};\n                }\n                modifier.$unset[key] = 1;\n              } else {\n                if (!modifier.$set) {\n                  modifier.$set = {};\n                }\n                modifier.$set[key] = value;\n              }\n            });\n            if (Object.keys(modifier).length > 0) {\n              await self._collection.updateAsync(mongoId, modifier);\n            }\n          }\n        } else {\n          throw new Error(\"I don't know how to deal with this message\");\n        }\n      },\n\n      // Called at the end of a batch of updates.\n      async endUpdate() {\n        await self._collection.resumeObserversServer();\n      },\n\n      // Used to preserve current versions of documents across a store reset.\n      async getDoc(id) {\n        return self.findOneAsync(id);\n      },\n      ...wrappedStoreCommon,\n    };\n\n\n    // OK, we're going to be a slave, replicating some remote\n    // database, except possibly with some temporary divergence while\n    // we have unacknowledged RPC's.\n    let registerStoreResult;\n    if (Meteor.isClient) {\n      registerStoreResult = self._connection.registerStoreClient(\n        name,\n        wrappedStoreClient\n      );\n    } else {\n      registerStoreResult = self._connection.registerStoreServer(\n        name,\n        wrappedStoreServer\n      );\n    }\n\n    const message = `There is already a collection named \"${name}\"`;\n    const logWarn = () => {\n      console.warn ? console.warn(message) : console.log(message);\n    };\n\n    if (!registerStoreResult) {\n      return logWarn();\n    }\n\n    return registerStoreResult?.then?.(ok => {\n      if (!ok) {\n        logWarn();\n      }\n    });\n  },\n}"],"mappings":"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","ignoreList":[]},"sourceType":"module","externalDependencies":{},"hash":"713a0031a853a2a96652334581fb6f8f76020f26"}
